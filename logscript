#region Configuration Parameters
$DaysToLookBack = 2                 # Analyze logs from the last N days
$MaxRunsPerScenario = 3             # Max valid runs to extract per scenario
$ReportOutputPath = "C:\LogReports" # Where to save the HTML file
$SendEmail = $false                 # Set to true to email the report

# SMTP Settings for Email Delivery
# To enable email delivery:
# 1. Set $SendEmail = $true above
# 2. Configure the settings below with your SMTP server details
$SMTPSettings = @{
    # SmtpServer = "smtp.gmail.com"           # SMTP server address
    # Port = 587                              # SMTP port (587 for TLS, 465 for SSL, 25 for basic)
    # From = "your-email@gmail.com"           # Sender email address
    # To = @("recipient1@company.com", "recipient2@company.com")  # Array of recipient emails
    # Subject = "Scenario Execution Report - $(Get-Date -Format 'yyyy-MM-dd')"  # Email subject
    # UseSsl = $true                          # Use SSL/TLS encryption
    # Credential = $null                      # Set this if authentication is required (see examples below)
}

# SMTP Authentication Examples:
# For Gmail/Office365 with app passwords:
# $SMTPSettings.Credential = New-Object System.Management.Automation.PSCredential("your-email@gmail.com", (ConvertTo-SecureString "your-app-password" -AsPlainText -Force))

# For servers requiring authentication with username/password:
# $SMTPSettings.Credential = Get-Credential  # This will prompt for credentials when script runs

# Example configurations:
# Gmail: SmtpServer="smtp.gmail.com", Port=587, UseSsl=$true, Credential required
# Outlook/Hotmail: SmtpServer="smtp-mail.outlook.com", Port=587, UseSsl=$true, Credential required  
# Office365: SmtpServer="smtp.office365.com", Port=587, UseSsl=$true, Credential required
# Exchange Server: SmtpServer="your-exchange-server.com", Port=25, UseSsl=$false (internal network)

# Ensure debug log directory exists before creating debug log path
if (!(Test-Path $ReportOutputPath)) {
    New-Item -ItemType Directory -Path $ReportOutputPath -Force | Out-Null
}
$DebugLog = Join-Path $ReportOutputPath "debug.log"

# Clear previous debug log
if (Test-Path $DebugLog) {
    Remove-Item $DebugLog -Force
}

#region Utility Functions
function Write-DebugLog {
    param($Message)
    try {
        Add-Content -Path $DebugLog -Value ("[{0}] {1}" -f (Get-Date -Format 'yyyy-MM-dd HH:mm:ss'), $Message)
        Write-Host "[DEBUG] $Message" -ForegroundColor Yellow
    } catch {
        Write-Host "[DEBUG ERROR] Failed to write to debug log: $_" -ForegroundColor Red
    }
}

function Import-Scenarios {
    param($Path = "scenarios.csv")
    Write-DebugLog "Attempting to import scenarios from: $Path"
    
    if (!(Test-Path $Path)) {
        Write-DebugLog "ERROR: Scenarios file not found: $Path"
        Write-Host "ERROR: Scenarios file not found: $Path" -ForegroundColor Red
        return @()
    }
    
    try {
        $scenarios = Import-Csv -Path $Path
        Write-DebugLog "Successfully imported $($scenarios.Count) scenarios"
        foreach ($scenario in $scenarios) {
            Write-DebugLog "  - Scenario: $($scenario.ScenarioName), LogPath: $($scenario.LogFilePath)"
        }
        return $scenarios
    } catch {
        Write-DebugLog "Failed to import scenarios.csv: $($_.Exception.Message)"
        Write-Host "ERROR: Failed to import scenarios.csv: $($_.Exception.Message)" -ForegroundColor Red
        return @()
    }
}

function Import-ErrorKeywords {
    param($Path = "errors.csv")
    Write-DebugLog "Attempting to import error keywords from: $Path"
    
    if (!(Test-Path $Path)) {
        Write-DebugLog "ERROR: Error keywords file not found: $Path"
        Write-Host "ERROR: Error keywords file not found: $Path" -ForegroundColor Red
        return @()
    }
    
    try {
        $keywords = (Import-Csv -Path $Path).ErrorKeyword | Where-Object { $_ -ne '' }
        Write-DebugLog "Successfully imported $($keywords.Count) error keywords: $($keywords -join ', ')"
        return $keywords
    } catch {
        Write-DebugLog "Failed to import errors.csv: $($_.Exception.Message)"
        Write-Host "ERROR: Failed to import errors.csv: $($_.Exception.Message)" -ForegroundColor Red
        return @()
    }
}

function Get-RecentLogFilesDescending {
    param($LogDir)
    Write-DebugLog "Searching for log files in directory: $LogDir"
    
    if (!(Test-Path $LogDir)) {
        Write-DebugLog "ERROR: Log directory does not exist: $LogDir"
        Write-Host "ERROR: Log directory does not exist: $LogDir" -ForegroundColor Red
        return @()
    }
    
    try {
        $cutoffDate = (Get-Date).AddDays(-$DaysToLookBack)
        Write-DebugLog "Looking for .log files modified after: $cutoffDate"
        
        $allLogFiles = Get-ChildItem -Path $LogDir -Filter *.log -File -ErrorAction Stop
        Write-DebugLog "Found $($allLogFiles.Count) total .log files in directory"
        
        $recentFiles = $allLogFiles | Where-Object { $_.LastWriteTime -ge $cutoffDate }
        Write-DebugLog "Found $($recentFiles.Count) recent log files (within $DaysToLookBack days)"
        
        foreach ($file in $recentFiles) {
            Write-DebugLog "  - File: $($file.Name), LastWriteTime: $($file.LastWriteTime), Size: $($file.Length) bytes"
        }
        
        $sortedFiles = $recentFiles | Sort-Object LastWriteTime -Descending
        Write-DebugLog "Returning $($sortedFiles.Count) files sorted by LastWriteTime descending"
        
        return $sortedFiles
    } catch {
        Write-DebugLog "Failed to get log files in ${LogDir}: $($_.Exception.Message)"
        Write-Host "ERROR: Failed to get log files in ${LogDir}: $($_.Exception.Message)" -ForegroundColor Red
        return @()
    }
}

function Read-LogFileReverse {
    param($LogFile)
    Write-DebugLog "Reading log file: $LogFile"
    
    if (!(Test-Path $LogFile)) {
        Write-DebugLog "ERROR: Log file does not exist: $LogFile"
        return @()
    }
    
    try {
        $fileInfo = Get-Item $LogFile
        Write-DebugLog "File size: $($fileInfo.Length) bytes, LastWriteTime: $($fileInfo.LastWriteTime)"
        
        $content = Get-Content -Path $LogFile -Raw -ErrorAction Stop -Encoding UTF8
        if ([string]::IsNullOrEmpty($content)) {
            Write-DebugLog "WARNING: Log file is empty: $LogFile"
            return @()
        }
        
        $lines = $content.Split("`n")
        Write-DebugLog "Read $($lines.Count) lines from log file"
        
        [array]::Reverse($lines)
        Write-DebugLog "Reversed line order for processing (newest first)"
        
        return $lines
    } catch {
        Write-DebugLog "Failed to read log file ${LogFile}: $($_.Exception.Message)"
        Write-Host "ERROR: Failed to read log file ${LogFile}: $($_.Exception.Message)" -ForegroundColor Red
        return @()
    }
}

function Detect-RunsInLog {
    param($Lines, $ErrorKeywords)
    Write-DebugLog "Analyzing $($Lines.Count) lines for scenario runs"
    
    $runs = @()
    # More flexible patterns to handle various timestamp and log formats
    # Pattern handles: YYYY/MM/DD HH:MM:SS.sss or YYYY/MM/DD HH:MM:S.sss (single digit seconds)
    $startPattern = '(?<ts>\d{4}/\d{2}/\d{2}\s+\d{1,2}:\d{1,2}:\d{1,2}(?:\.\d{1,3})?)\s+.*Starting\s+Connect-It'
    $endPattern = '(?<ts>\d{4}/\d{2}/\d{2}\s+\d{1,2}:\d{1,2}:\d{1,2}(?:\.\d{1,3})?)\s+.*Operation\s+completed.*RC=(?<rc>\d+)'
    
    Write-DebugLog "Using patterns - Start: '$startPattern', End: '$endPattern'"
    
    # Add debug logging for first few lines to see actual format
    Write-DebugLog "Sample lines for pattern matching:"
    for ($j = 0; $j -lt [Math]::Min(20, $Lines.Count); $j++) {
        if (![string]::IsNullOrWhiteSpace($Lines[$j])) {
            Write-DebugLog "  Line $j`: $($Lines[$j].Trim())"
        }
    }
    
    # First pass: Find all START and END markers with their positions and timestamps
    $startMarkers = @()
    $endMarkers = @()
    
    for ($i = 0; $i -lt $Lines.Count; $i++) {
        $line = $Lines[$i].Trim()
        
        # Skip empty lines
        if ([string]::IsNullOrWhiteSpace($line)) {
            continue
        }
        
        # Test START pattern with detailed debugging
        if ($line -match $startPattern) {
            $startMarkers += @{
                LineIndex = $i
                Timestamp = $matches['ts'].Trim()
                Line = $line
                ParsedTime = $null
            }
            Write-DebugLog "Found START marker at line ${i}: '$($matches['ts'].Trim())'"
        }
        # Test END pattern with detailed debugging  
        elseif ($line -match $endPattern) {
            $endMarkers += @{
                LineIndex = $i
                Timestamp = $matches['ts'].Trim()
                RC = $matches['rc']
                Line = $line
                ParsedTime = $null
            }
            Write-DebugLog "Found END marker at line ${i}: '$($matches['ts'].Trim())' RC=$($matches['rc'])"
        }
        # Debug lines that contain keywords but don't match patterns
        elseif ($line -like "*Starting Connect-It*") {
            Write-DebugLog "WARNING: Line contains 'Starting Connect-It' but doesn't match pattern: $line"
        }
        elseif ($line -like "*Operation completed*") {
            Write-DebugLog "WARNING: Line contains 'Operation completed' but doesn't match pattern: $line"
        }
    }
    
    Write-DebugLog "Found $($startMarkers.Count) START markers and $($endMarkers.Count) END markers"
    
    # Parse timestamps for comparison - handle multiple formats
    foreach ($marker in ($startMarkers + $endMarkers)) {
        $timestamp = $marker.Timestamp.Trim()
        Write-DebugLog "Attempting to parse timestamp: '$timestamp'"
        
        # Try multiple timestamp formats
        $formats = @(
            'yyyy/MM/dd HH:mm:ss.fff',
            'yyyy/MM/dd HH:mm:ss.ff', 
            'yyyy/MM/dd HH:mm:ss.f',
            'yyyy/MM/dd HH:mm:ss',
            'yyyy/MM/dd H:mm:ss.fff',
            'yyyy/MM/dd H:mm:ss.ff',
            'yyyy/MM/dd H:mm:ss.f',
            'yyyy/MM/dd H:mm:ss',
            'yyyy/MM/dd HH:mm:s.fff',
            'yyyy/MM/dd HH:mm:s.ff',
            'yyyy/MM/dd HH:mm:s.f',
            'yyyy/MM/dd HH:mm:s',
            'yyyy/MM/dd H:mm:s.fff',
            'yyyy/MM/dd H:mm:s.ff',
            'yyyy/MM/dd H:mm:s.f',
            'yyyy/MM/dd H:mm:s'
        )
        
        $parsed = $false
        foreach ($format in $formats) {
            try {
                $marker.ParsedTime = [datetime]::ParseExact($timestamp, $format, $null)
                Write-DebugLog "Successfully parsed '$timestamp' using format '$format' -> $($marker.ParsedTime)"
                $parsed = $true
                break
            } catch {
                # Continue to next format
            }
        }
        
        if (-not $parsed) {
            Write-DebugLog "WARNING: Could not parse timestamp '$timestamp' with any known format"
            $marker.ParsedTime = $null
        }
    }
    
    # Sort markers by line index (since lines are already reversed, this gives us newest first)
    $startMarkers = $startMarkers | Sort-Object LineIndex
    $endMarkers = $endMarkers | Sort-Object LineIndex
    
    Write-DebugLog "Processing markers to find valid start-end pairs..."
    
    # Process each END marker and find its corresponding START marker
    foreach ($endMarker in $endMarkers) {
        Write-DebugLog "Processing END marker at line $($endMarker.LineIndex): $($endMarker.Timestamp)"
        
        # Find the next START marker that comes after this END marker (chronologically before, since lines are reversed)
        $matchingStart = $null
        foreach ($startMarker in $startMarkers) {
            # The start marker should be at a higher line index (later in the reversed array = earlier in time)
            if ($startMarker.LineIndex -gt $endMarker.LineIndex) {
                # Validate timestamps: start time should be less than end time
                if ($startMarker.ParsedTime -and $endMarker.ParsedTime) {
                    if ($startMarker.ParsedTime -lt $endMarker.ParsedTime) {
                        $matchingStart = $startMarker
                        Write-DebugLog "  - Found matching START at line $($startMarker.LineIndex): $($startMarker.Timestamp)"
                        break
                    } else {
                        Write-DebugLog "  - START at line $($startMarker.LineIndex) has time $($startMarker.Timestamp) which is >= END time $($endMarker.Timestamp) - INVALID"
                    }
                } else {
                    # If we can't parse timestamps, assume the first START after END is the match
                    $matchingStart = $startMarker
                    Write-DebugLog "  - Found START at line $($startMarker.LineIndex) (timestamp parsing failed, assuming valid)"
                    break
                }
            }
        }
        
        if ($matchingStart) {
            # Create a valid run
            $run = @{
                StartTime = $matchingStart.Timestamp
                EndTime = $endMarker.Timestamp
                RC = $endMarker.RC
                StartIdx = $matchingStart.LineIndex
                EndIdx = $endMarker.LineIndex
                Status = if ($endMarker.RC -eq '0') { 'Success' } else { 'Failed' }
                ErrorCount = 0
                KeywordsFound = ''
                Errors = @()
            }
            
            # Extract run lines between start and end for error analysis
            $runLines = $Lines[$endMarker.LineIndex..$matchingStart.LineIndex]
            Write-DebugLog "  - Extracted $($runLines.Count) lines for error analysis"
            
            # Analyze error keywords
            $foundKeywords = @()
            foreach ($kw in $ErrorKeywords) {
                $matchesCount = ($runLines | Select-String -Pattern $kw -SimpleMatch).Count
                if ($matchesCount -gt 0) { 
                    $foundKeywords += $kw 
                    Write-DebugLog "  - Found $matchesCount occurrences of keyword '$kw'"
                }
                $run.ErrorCount += $matchesCount
            }
            $run.KeywordsFound = $foundKeywords -join ', '
            
            # Update status based on error keywords found
            if ($run.Status -eq 'Success' -and $run.ErrorCount -gt 0) {
                $run.Status = 'Success with Warnings'
                Write-DebugLog "  - Status updated to 'Success with Warnings' due to error keywords"
            }
            
            Write-DebugLog "  - Created run: Status=$($run.Status), Start=$($run.StartTime), End=$($run.EndTime), Errors=$($run.ErrorCount)"
            $runs += $run
            
            # Remove the used START marker so it can't be matched again
            $startMarkers = $startMarkers | Where-Object { $_.LineIndex -ne $matchingStart.LineIndex }
        } else {
            Write-DebugLog "  - No matching START found for END at line $($endMarker.LineIndex) - orphaned END marker"
        }
    }
    
    # Check for unmatched START markers (scenarios that started but didn't complete)
    foreach ($startMarker in $startMarkers) {
        Write-DebugLog "Found unmatched START marker at line $($startMarker.LineIndex): $($startMarker.Timestamp) - marking as Incomplete"
        $run = @{
            StartTime = $startMarker.Timestamp
            EndTime = $null
            RC = $null
            StartIdx = $startMarker.LineIndex
            EndIdx = $null
            Status = 'Incomplete'
            ErrorCount = 0
            KeywordsFound = 'Scenario started but not completed'
            Errors = @()
        }
        $runs += $run
    }
    
    Write-DebugLog "Total runs detected: $($runs.Count)"
    return $runs
}

function Calculate-RunDuration {
    param($Start, $End)
    
    # Multiple timestamp formats to try
    $formats = @(
        'yyyy/MM/dd HH:mm:ss.fff',
        'yyyy/MM/dd HH:mm:ss.ff',
        'yyyy/MM/dd HH:mm:ss.f',
        'yyyy/MM/dd HH:mm:ss',
        'yyyy/MM/dd HH:mm:s.fff',
        'yyyy/MM/dd HH:mm:s.ff',
        'yyyy/MM/dd HH:mm:s.f',
        'yyyy/MM/dd HH:mm:s',
        'yyyy/MM/dd H:mm:ss.fff',
        'yyyy/MM/dd H:mm:ss.ff',
        'yyyy/MM/dd H:mm:ss.f',
        'yyyy/MM/dd H:mm:ss',
        'yyyy/MM/dd H:mm:s.fff',
        'yyyy/MM/dd H:mm:s.ff',
        'yyyy/MM/dd H:mm:s.f',
        'yyyy/MM/dd H:mm:s'
    )
    
    $startDT = $null
    $endDT = $null
    
    # Parse start time
    foreach ($format in $formats) {
        try {
            $startDT = [datetime]::ParseExact($Start, $format, $null)
            Write-DebugLog "Successfully parsed start time '$Start' using format '$format'"
            break
        } catch {
            # Continue to next format
        }
    }
    
    # Parse end time
    foreach ($format in $formats) {
        try {
            $endDT = [datetime]::ParseExact($End, $format, $null)
            Write-DebugLog "Successfully parsed end time '$End' using format '$format'"
            break
        } catch {
            # Continue to next format
        }
    }
    
    if ($startDT -and $endDT) {
        $duration = $endDT - $startDT
        Write-DebugLog "Calculated duration: $($duration.ToString())"
        return $duration.ToString()
    } else {
        Write-DebugLog "Failed to parse duration - Start: '$Start', End: '$End'"
        return ''
    }
}

function Get-LastSuccessTimestamp {
    param($Runs)
    
    # Include both 'Success' and 'Success with Warnings' as successful runs
    $success = $Runs | Where-Object { $_.Status -eq 'Success' -or $_.Status -eq 'Success with Warnings' } | Sort-Object EndTime -Descending | Select-Object -First 1
    
    if ($success) {
        # Multiple timestamp formats to try
        $formats = @(
            'yyyy/MM/dd HH:mm:ss.fff',
            'yyyy/MM/dd HH:mm:ss.ff',
            'yyyy/MM/dd HH:mm:ss.f',
            'yyyy/MM/dd HH:mm:ss',
            'yyyy/MM/dd HH:mm:s.fff',
            'yyyy/MM/dd HH:mm:s.ff',
            'yyyy/MM/dd HH:mm:s.f',
            'yyyy/MM/dd HH:mm:s',
            'yyyy/MM/dd H:mm:ss.fff',
            'yyyy/MM/dd H:mm:ss.ff',
            'yyyy/MM/dd H:mm:ss.f',
            'yyyy/MM/dd H:mm:ss',
            'yyyy/MM/dd H:mm:s.fff',
            'yyyy/MM/dd H:mm:s.ff',
            'yyyy/MM/dd H:mm:s.f',
            'yyyy/MM/dd H:mm:s'
        )
        
        foreach ($format in $formats) {
            try {
                $timestamp = [datetime]::ParseExact($success.EndTime, $format, $null)
                Write-DebugLog "Successfully parsed last success timestamp '$($success.EndTime)' using format '$format' -> Status: $($success.Status)"
                return $timestamp
            } catch {
                # Continue to next format
            }
        }
        
        Write-DebugLog "Failed to parse last success timestamp: $($success.EndTime)"
        return $null
    }
    return $null
}

function Generate-HTMLReport {
    param($ScenarioResults)
    Write-DebugLog "Generating HTML report for $($ScenarioResults.Count) scenarios"
    
    $date = Get-Date -Format 'yyyyMMdd'
    $htmlPath = Join-Path $ReportOutputPath "summary-$date.html"
    Write-DebugLog "HTML report path: $htmlPath"
    
    $html = @"
<html><head><title>Scenario Execution Report $date</title>
<style>
table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
th, td { border: 1px solid #ccc; padding: 6px; text-align: left; }
th { background: #eee; }
.success { background: #cfc; }
.failed { background: #fcc; }
.incomplete { background: #ffc; }
.success-with-warnings { background: #ffe6cc; }
h1 { color: #333; }
h2 { color: #666; margin-top: 30px; }
.summary { background: #f9f9f9; padding: 10px; margin-bottom: 20px; border-left: 4px solid #007acc; }
</style></head><body>
<h1>Scenario Execution Report - $date</h1>
<div class="summary">
<strong>Analysis Summary:</strong><br/>
- Report generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')<br/>
- Days analyzed: $DaysToLookBack days<br/>
- Scenarios processed: $($ScenarioResults.Count)<br/>
- Debug log: $DebugLog
</div>
"@

    $totalRuns = 0
    foreach ($result in $ScenarioResults) {
        $runCount = $result.Runs.Count
        $totalRuns += $runCount
        Write-DebugLog "Adding scenario '$($result.ScenarioName)' with $runCount runs to report"
        
        $html += "<h2>$($result.ScenarioName) ($runCount runs)</h2>"
        
        if ($runCount -eq 0) {
            $html += "<p><em>No runs found for this scenario.</em></p>"
        } else {
            $html += "<table><tr><th>Run Date</th><th>Start Time</th><th>End Time</th><th>Duration</th><th>Status</th><th>Error Count</th><th>Time Since Last Success</th><th>Keywords Found</th><th>Log File</th></tr>"
            
            foreach ($run in $result.Runs) {
                $rowClass = switch ($run.Status) {
                    'Success' { 'success' }
                    'Success with Warnings' { 'success-with-warnings' }
                    'Failed' { 'failed' }
                    'Incomplete' { 'incomplete' }
                    default { '' }
                }
                $runDate = if ($run.EndTime) { $run.EndTime.Split(' ')[0] } else { 'N/A' }
                $html += "<tr class='$rowClass'><td>$runDate</td><td>$($run.StartTime)</td><td>$($run.EndTime)</td><td>$($run.Duration)</td><td>$($run.Status)</td><td>$($run.ErrorCount)</td><td>$($run.TimeSinceLastSuccess)</td><td>$($run.KeywordsFound)</td><td>$($run.LogFile)</td></tr>"
            }
            $html += "</table>"
        }
    }
    
    $html += "<div class='summary'><strong>Total runs across all scenarios: $totalRuns</strong></div>"
    $html += "</body></html>"
    
    try {
        $null = New-Item -ItemType Directory -Path $ReportOutputPath -Force
        Set-Content -Path $htmlPath -Value $html -Encoding UTF8
        Write-DebugLog "HTML report successfully written to: $htmlPath"
        return $htmlPath
    } catch {
        Write-DebugLog "ERROR: Failed to write HTML report: $($_.Exception.Message)"
        Write-Host "ERROR: Failed to write HTML report: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

function Send-EmailReport {
    param($HtmlPath)
    
    if (!$SendEmail) {
        Write-DebugLog "Email delivery disabled (SendEmail = false)"
        return
    }
    
    if ($SMTPSettings.Count -eq 0) {
        Write-DebugLog "WARNING: Email delivery enabled but no SMTP settings configured"
        Write-Host "WARNING: Email delivery enabled but no SMTP settings configured. Please configure SMTPSettings." -ForegroundColor Yellow
        return
    }
    
    # Validate required SMTP settings
    $requiredSettings = @('SmtpServer', 'From', 'To')
    $missingSettings = @()
    foreach ($setting in $requiredSettings) {
        if (!$SMTPSettings.ContainsKey($setting) -or [string]::IsNullOrEmpty($SMTPSettings[$setting])) {
            $missingSettings += $setting
        }
    }
    
    if ($missingSettings.Count -gt 0) {
        $missingList = $missingSettings -join ', '
        Write-DebugLog "ERROR: Missing required SMTP settings: $missingList"
        Write-Host "ERROR: Missing required SMTP settings: $missingList" -ForegroundColor Red
        return
    }
    
    try {
        Write-DebugLog "Attempting to send email report via $($SMTPSettings.SmtpServer)"
        Write-Host "Sending email report..." -ForegroundColor Cyan
        
        $emailParams = $SMTPSettings.Clone()
        
        # Set default subject if not provided
        if (!$emailParams.ContainsKey('Subject')) {
            $emailParams.Subject = "Scenario Execution Report - $(Get-Date -Format 'yyyy-MM-dd')"
        }
        
        # Read HTML content for email body
        $body = Get-Content -Path $HtmlPath -Raw -Encoding UTF8
        $emailParams.Body = $body
        $emailParams.BodyAsHtml = $true
        $emailParams.Attachments = $HtmlPath
        
        Send-MailMessage @emailParams
        
        Write-DebugLog "Email sent successfully to: $($SMTPSettings.To -join ', ')"
        Write-Host "Email sent successfully!" -ForegroundColor Green
        
    } catch {
        Write-DebugLog "Failed to send email: $($_.Exception.Message)"
        Write-Host "ERROR: Failed to send email: $($_.Exception.Message)" -ForegroundColor Red
        
        # Provide helpful troubleshooting information
        if ($_.Exception.Message -like "*authentication*" -or $_.Exception.Message -like "*login*") {
            Write-Host "HINT: Check your SMTP credentials. For Gmail/Office365, you may need an app-specific password." -ForegroundColor Yellow
        }
        elseif ($_.Exception.Message -like "*connection*" -or $_.Exception.Message -like "*timeout*") {
            Write-Host "HINT: Check your SMTP server address, port, and SSL settings." -ForegroundColor Yellow
        }
    }
}

#endregion

#region Main Logic
Write-DebugLog "=== STARTING SCENARIO LOG ANALYSIS ==="
Write-DebugLog "Configuration: DaysToLookBack=$DaysToLookBack, MaxRunsPerScenario=$MaxRunsPerScenario"
Write-DebugLog "Report Output Path: $ReportOutputPath"

$scenarios = Import-Scenarios
if ($scenarios.Count -eq 0) {
    Write-DebugLog "ERROR: No scenarios loaded. Exiting."
    Write-Host "ERROR: No scenarios loaded. Please check scenarios.csv file." -ForegroundColor Red
    exit 1
}

$errorKeywords = Import-ErrorKeywords
if ($errorKeywords.Count -eq 0) {
    Write-DebugLog "WARNING: No error keywords loaded."
    Write-Host "WARNING: No error keywords loaded. Please check errors.csv file." -ForegroundColor Yellow
}

$ScenarioResults = @()

foreach ($scenario in $scenarios) {
    Write-DebugLog "=== PROCESSING SCENARIO: $($scenario.ScenarioName) ==="
    Write-Host "Processing scenario: $($scenario.ScenarioName)" -ForegroundColor Cyan
    
    $logFiles = Get-RecentLogFilesDescending -LogDir $scenario.LogFilePath
    if ($logFiles.Count -eq 0) {
        Write-DebugLog "WARNING: No recent log files found for scenario $($scenario.ScenarioName)"
        Write-Host "  WARNING: No recent log files found" -ForegroundColor Yellow
        continue
    }
    
    $allRuns = @()
    
    foreach ($logFile in $logFiles) {
        Write-DebugLog "--- Processing log file: $($logFile.Name) ---"
        Write-Host "  Processing file: $($logFile.Name)" -ForegroundColor Gray
        
        $lines = Read-LogFileReverse -LogFile $logFile.FullName
        if ($lines.Count -eq 0) {
            Write-DebugLog "WARNING: No lines read from log file $($logFile.Name)"
            continue
        }
        
        $runs = Detect-RunsInLog -Lines $lines -ErrorKeywords $errorKeywords
        Write-DebugLog "Found $($runs.Count) runs in file $($logFile.Name)"
        
        foreach ($run in $runs) {
            $run.LogFile = $logFile.Name
            $run.Duration = if ($run.StartTime -and $run.EndTime) { 
                Calculate-RunDuration $run.StartTime $run.EndTime 
            } else { 
                '' 
            }
            $allRuns += $run
            Write-DebugLog "Added run: Status=$($run.Status), StartTime=$($run.StartTime), EndTime=$($run.EndTime), Duration=$($run.Duration)"
            
            if ($allRuns.Count -ge $MaxRunsPerScenario) { 
                Write-DebugLog "Reached MaxRunsPerScenario limit ($MaxRunsPerScenario), stopping file processing"
                break 
            }
        }
        if ($allRuns.Count -ge $MaxRunsPerScenario) { break }
    }
    
    Write-DebugLog "Total runs collected for scenario $($scenario.ScenarioName): $($allRuns.Count)"
    
    # Calculate time since last success
    $lastSuccess = Get-LastSuccessTimestamp -Runs $allRuns
    if ($lastSuccess) {
        Write-DebugLog "Last success timestamp: $lastSuccess"
    } else {
        Write-DebugLog "No successful runs found for scenario $($scenario.ScenarioName)"
    }
    
    foreach ($run in $allRuns) {
        if ($lastSuccess) {
            $run.TimeSinceLastSuccess = (New-TimeSpan -Start $lastSuccess -End (Get-Date)).ToString()
        } else {
            $run.TimeSinceLastSuccess = 'No recent success'
        }
    }
    
    $ScenarioResults += [PSCustomObject]@{
        ScenarioName = $scenario.ScenarioName
        Runs = $allRuns
    }
    
    Write-Host "  Completed: $($allRuns.Count) runs found" -ForegroundColor Green
}

Write-DebugLog "=== GENERATING REPORT ==="
Write-Host "Generating HTML report..." -ForegroundColor Cyan

$htmlPath = Generate-HTMLReport -ScenarioResults $ScenarioResults
Write-DebugLog "HTML report generated: $htmlPath"
Write-Host "Report generated: $htmlPath" -ForegroundColor Green

Send-EmailReport -HtmlPath $htmlPath

Write-DebugLog "=== ANALYSIS COMPLETE ==="
Write-Host "Analysis complete! Check debug log at: $DebugLog" -ForegroundColor Green
#endregion
