#region Configuration
$ScenariosCsvPath = "scenarios.csv"
$ErrorsCsvPath = "errors.csv"
$DaysToLookBack = 2
$MaxRunsPerScenario = 3
$ReportOutputPath = "C:\LogReports"
$Now = Get-Date

if (-not (Test-Path $ReportOutputPath)) {
    New-Item -Path $ReportOutputPath -ItemType Directory | Out-Null
}
#endregion

#region Utility Functions
function Import-ErrorKeywords {
    return Import-Csv -Path $ErrorsCsvPath | ForEach-Object { $_.ErrorKeyword.ToLower() }
}

function Import-Scenarios {
    return Import-Csv -Path $ScenariosCsvPath
}

function Get-RecentLogFilesDescending($logPath) {
    return Get-ChildItem -Path $logPath -Filter *.log -File |
        Where-Object { $_.LastWriteTime -ge ($Now.AddDays(-$DaysToLookBack)) } |
        Sort-Object LastWriteTime -Descending
}

function Read-LogFileReverse($filePath) {
    $lines = Get-Content -Path $filePath -Raw | Out-String | Select-String ".*" -AllMatches | ForEach-Object { $_.Matches.Value }
    [array]::Reverse($lines)
    return $lines
}

function Parse-DateTime($line) {
    if ($line -match '^(\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2})') {
        try {
            return [datetime]::ParseExact($matches[1], 'yyyy/MM/dd HH:mm:ss', $null)
        } catch {
            return $null
        }
    }
    return $null
}

function Analyze-ScenarioLogs($scenario, $errorKeywords) {
    $runs = @()
    $lastSuccessTime = $null
    $files = Get-RecentLogFilesDescending $scenario.LogFilePath

    foreach ($file in $files) {
        $lines = Read-LogFileReverse $file.FullName
        $currentRun = @()
        $startLine = $null
        $endLine = $null
        $startTime = $null
        $endTime = $null
        $status = "Incomplete"
        $errorCount = 0
        $keywordsFound = @()

        foreach ($line in $lines) {
            if ($null -eq $endLine -and $line -match "RC=\d") {
                $endLine = $line
                $endTime = Parse-DateTime $line
            } elseif ($null -ne $endLine -and $line -match "Starting Connect-It") {
                $startLine = $line
                $startTime = Parse-DateTime $line
                $duration = if ($startTime -and $endTime) { ($endTime - $startTime).ToString("hh\:mm\:ss") } else { "N/A" }
                
                $runBlock = $lines[($lines.IndexOf($line))..($lines.IndexOf($endLine))]
                foreach ($kw in $errorKeywords) {
                    $matches = $runBlock | Where-Object { $_.ToLower().Contains($kw) }
                    if ($matches.Count -gt 0) {
                        $errorCount += $matches.Count
                        $keywordsFound += $kw
                    }
                }
                $status = if ($endLine -match "RC=0") { "Success" } else { "Failed" }
                if ($status -eq "Success") {
                    $lastSuccessTime = $endTime
                }

                $runs += [PSCustomObject]@{
                    Scenario     = $scenario.ScenarioName
                    RunDate      = $startTime.ToShortDateString()
                    StartTime    = $startTime
                    EndTime      = $endTime
                    Duration     = $duration
                    Status       = $status
                    ErrorCount   = $errorCount
                    TimeSinceLastSuccess = "TBD"
                    KeywordsFound = ($keywordsFound -join ", ")
                    LogFile      = $file.Name
                }

                $startLine = $null; $endLine = $null; $startTime = $null; $endTime = $null; $errorCount = 0; $keywordsFound = @()
                if ($runs.Count -ge $MaxRunsPerScenario) { break }
            }
        }
        if ($runs.Count -ge $MaxRunsPerScenario) { break }
    }

    $runs | ForEach-Object {
        $_.TimeSinceLastSuccess = if ($lastSuccessTime) { ($Now - $lastSuccessTime).ToString("dd\.hh\:mm") } else { "No Success Found" }
    }
    return $runs
}

function Generate-HTMLReport($allRuns) {
    $html = @"
    <html><head>
    <style>
    table { border-collapse: collapse; width: 100%; font-family: Arial; }
    th, td { border: 1px solid #ddd; padding: 8px; }
    th { background-color: #f2f2f2; }
    </style></head><body>
    <h2>Scenario Execution Summary Report - $($Now.ToString("yyyy-MM-dd HH:mm"))</h2>
    <table>
        <tr>
            <th>Scenario</th><th>Run Date</th><th>Start Time</th><th>End Time</th>
            <th>Duration</th><th>Status</th><th>Error Count</th>
            <th>Time Since Last Success</th><th>Keywords Found</th><th>Log File</th>
        </tr>
"@

    foreach ($run in $allRuns) {
        $html += "<tr><td>$($run.Scenario)</td><td>$($run.RunDate)</td><td>$($run.StartTime)</td><td>$($run.EndTime)</td>"
        $html += "<td>$($run.Duration)</td><td>$($run.Status)</td><td>$($run.ErrorCount)</td>"
        $html += "<td>$($run.TimeSinceLastSuccess)</td><td>$($run.KeywordsFound)</td><td>$($run.LogFile)</td></tr>"
    }

    $html += "</table></body></html>"
    $fileName = "summary-$($Now.ToString('yyyyMMdd-HHmm')).html"
    $fullPath = Join-Path $ReportOutputPath $fileName
    $html | Out-File -FilePath $fullPath -Encoding UTF8
    Write-Output "Report saved to $fullPath"
}
#endregion

#region Main Execution
$scenarios = Import-Scenarios
$errorKeywords = Import-ErrorKeywords
$allRuns = @()

foreach ($scenario in $scenarios) {
    Write-Output "Analyzing scenario: $($scenario.ScenarioName)"
    $runs = Analyze-ScenarioLogs -scenario $scenario -errorKeywords $errorKeywords
    $allRuns += $runs
}

Generate-HTMLReport -allRuns $allRuns
#endregion
